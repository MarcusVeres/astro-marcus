---
import { type CollectionEntry } from "astro:content";

interface Props {
  portfolioItems: CollectionEntry<"portfolio">[];
  transitionType?: string;
}

const { portfolioItems, transitionType } = Astro.props;
// Transform portfolio items into image-like structure for the lightbox
const images = portfolioItems.map(item => ({
  src: item.data.image,
  alt: item.data.title,
  title: item.data.title,
  description: item.data.description
}));
---

<!-- Lightbox Dialog Only (thumbnails are in main grid) -->
<dialog class="lightbox-dialog border-none p-0 overflow-clip bg-transparent" data-option={transitionType || "slide-in"}>
    <div class="lightbox-content w-screen h-screen grid grid-cols-1 grid-rows-1">
      {
        images.map((image, index) => (
          <figure class="lightbox-image-container grid grid-cols-1 place-content-center opacity-0 pointer-events-none transition-all" id={`image-${index}`}>
            {/* For performance, only the first few images are eager loaded */}
            <div class="lightbox-image-wrapper flex items-center justify-center">
              <img
                src={image.src}
                alt={image.alt}
                loading={index < 4 ? "eager" : "lazy"}
                class="lightbox-image max-w-full w-auto h-auto mx-auto block"
                data-index={index}
              />
            </div>
            <figcaption class="lightbox-caption px-2 py-4 opacity-100 transition-opacity">
              {image.title ? (
                <p class="font-extrabold text-center mx-auto text-gray-50 text-balance pt-6 pb-3">
                  {index + 1}. {image.title}
                </p>
              ) : null}
              {image.description ? (
                <p class="font-light text-center mx-auto text-gray-50 text-balance">
                  {image.description}
                </p>
              ) : null}
            </figcaption>
          </figure>
        ))
      }
    </div>
    <!-- Navigation buttons -->
    <button class="prev-button block bg-transparent border-none outline-none cursor-pointer z-[999] opacity-100 transition-opacity" aria-label="previous slide">
      <svg
        class="text-teal-400/75 w-9 h-full aspect-square p-0 transition-all duration-200 hover:text-teal-300/95"
        xmlns="http://www.w3.org/2000/svg"
        width="32"
        height="32"
        viewBox="0 0 32 32"
      >
        <path
          fill="currentColor"
          d="M16 2a14 14 0 1 0 14 14A14 14 0 0 0 16 2m8 15H11.85l5.58 5.573L16 24l-8-8l8-8l1.43 1.393L11.85 15H24Z"
        >
        </path>
        <path
          fill="none"
          d="m16 8l1.43 1.393L11.85 15H24v2H11.85l5.58 5.573L16 24l-8-8z"
        ></path>
      </svg>
    </button>
    <button class="next-button block bg-transparent border-none outline-none cursor-pointer z-[999] opacity-100 transition-opacity" aria-label="next slide">
      <svg
        class="text-teal-400/75 w-9 h-full aspect-square p-0 transition-all duration-200 hover:text-teal-300/95"
        xmlns="http://www.w3.org/2000/svg"
        width="32"
        height="32"
        viewBox="0 0 32 32"
      >
        <path
          fill="currentColor"
          d="M2 16A14 14 0 1 0 16 2A14 14 0 0 0 2 16m6-1h12.15l-5.58-5.607L16 8l8 8l-8 8l-1.43-1.427L20.15 17H8Z"
        >
        </path>
        <path
          fill="none"
          d="m16 8l-1.43 1.393L20.15 15H8v2h12.15l-5.58 5.573L16 24l8-8z"
        ></path>
      </svg>
    </button>
    <button class="close-button block bg-transparent border-none outline-none cursor-zoom-out z-[999] opacity-100 transition-opacity" aria-label="close button">
      <svg
        class="text-teal-400/75 w-9 h-full aspect-square p-0 transition-all duration-200 hover:text-teal-300/95"
        xmlns="http://www.w3.org/2000/svg"
        width="32"
        height="32"
        viewBox="0 0 32 32"
      >
        <path
          fill="currentColor"
          d="M16 2C8.2 2 2 8.2 2 16s6.2 14 14 14s14-6.2 14-14S23.8 2 16 2m5.4 21L16 17.6L10.6 23L9 21.4l5.4-5.4L9 10.6L10.6 9l5.4 5.4L21.4 9l1.6 1.6l-5.4 5.4l5.4 5.4z"
        >
        </path>
      </svg>
    </button>
  </dialog>

<style>
  /* Lightbox CSS Custom Properties & Critical Animations */
  .lightbox-dialog {
    /* Animation durations - customizable */
    --duration-zoom-in: 0.75s;
    --duration-background-transition: 0.3s;
    --duration-slide-transition: 0.3s;
    --duration-close-transition: 0.5s;
    --caption-height: 5lh;
    --ease-zoom: cubic-bezier(0.5, -0.5, 0.1, 1.5);
    --ease-slide-transition: cubic-bezier(0.9, 0, 0.1, 1);
  }

  @media (prefers-reduced-motion) {
    .lightbox-dialog {
      --duration-zoom-in: 0s;
      --duration-slide-transition: 0s;
      --duration-background-transition: 0s;
      --duration-close-transition: 0s;
    }
  }

  /* Prevent page scroll when lightbox is open */
  html:has(dialog[open]) {
    overflow: hidden;
  }

  /* Dialog Exit State (before opening) */
  .lightbox-dialog {
    opacity: 0;
    display: none;
    transform: translateX(100%);
    transition:
      overlay 1s ease-in allow-discrete,
      display 1s ease-in allow-discrete;
  }

  @media (width <= 640px) {
    .lightbox-dialog {
      transition:
        overlay 0s ease-in allow-discrete,
        display 0s ease-in allow-discrete;
    }
  }

  /* Dialog Open State with Named Grid Areas for Button Positioning */
  .lightbox-dialog[open] {
    opacity: 1;
    max-width: 100%;
    max-height: 100%;
    height: 100dvh;
    display: grid;
    grid-template-columns: [main-start] 10ch [interior-start] 1fr[interior-end] 10ch [main-end];
    grid-template-rows: [main-start] 5ch [interior-start] 1fr [interior-end] 5ch [main-end];
    grid-template-areas:
      "tlhs top trhs"
      "clhs content crhs"
      "blhs bottom brhs";
    transform: translateX(0);
  }

  /* Starting style (entry animation) */
  @starting-style {
    .lightbox-dialog[open] {
      translate: 0 100vh;
    }
    .lightbox-dialog[open]::backdrop {
      opacity: 0;
    }
    .lightbox-dialog[open] .lightbox-content .lightbox-image-container .lightbox-caption {
      opacity: 0;
    }
    .lightbox-dialog[open] button {
      opacity: 0;
    }
  }

  /* Backdrop styling */
  .lightbox-dialog::backdrop {
    opacity: 0;
    background: oklch(40% 0 0 / 95%);
  }

  .lightbox-dialog[open]::backdrop {
    opacity: 1;
  }

  /* Closing state */
  .lightbox-dialog.closing,
  .lightbox-dialog.closing::backdrop {
    opacity: 0;
    transition: opacity var(--duration-close-transition) ease;
  }

  /* Lightbox Content Grid */
  .lightbox-content {
    grid-column: main-start / main-end;
    grid-row: main-start / main-end;
    grid-template-areas: "content";
  }

  /* Image Container Grid Layout */
  .lightbox-image-container {
    grid-area: content;
    grid-template-rows: 1fr var(--caption-height);
    grid-template-areas:
      "image"
      "caption";
    transition:
      opacity var(--duration-slide-transition) var(--ease-slide-transition),
      transform var(--duration-slide-transition) var(--ease-slide-transition);
  }

  .lightbox-image-container.active {
    opacity: 1;
    pointer-events: auto;
  }

  .lightbox-image-wrapper {
    grid-area: image;
  }

  .lightbox-caption {
    grid-area: caption;
    transition: opacity var(--duration-background-transition) ease-in;
  }

  /* Image animation properties (set by JS) */
  .lightbox-image {
    --initial-scale: 1;
    --initial-x: 0px;
    --initial-y: 0px;
    --final-x: 0px;
    --final-y: 0px;
    --final-scale: 1;
    max-height: calc(100dvh - var(--caption-height));
    transform-origin: center center;
    animation: zoom-in-animation var(--duration-zoom-in) var(--ease-zoom) forwards;
  }

  @keyframes zoom-in-animation {
    from {
      transform: translate(var(--initial-x), var(--initial-y)) scale(var(--initial-scale));
    }
    to {
      transform: translate(var(--final-x), var(--final-y)) scale(var(--final-scale));
    }
  }

  /* Transition type: fade */
  .lightbox-dialog[data-option="fade"] .lightbox-image-container {
    transform: none;
  }

  /* Transition type: slide */
  .lightbox-dialog[data-option="slide"] .lightbox-image-container {
    transform: translateX(100%);
  }

  .lightbox-dialog[data-option="slide"] .lightbox-image-container.previous {
    transform: translateX(-100%);
  }

  .lightbox-dialog[data-option="slide"] .lightbox-image-container.next {
    transform: translateX(100%);
  }

  .lightbox-dialog[data-option="slide"] .lightbox-image-container.active {
    transform: translateX(0%);
  }

  /* Navigation Button Grid Positioning */
  .prev-button {
    grid-area: clhs;
    padding-right: 50%;
  }

  .next-button {
    grid-area: crhs;
    padding-left: 50%;
  }

  .close-button {
    grid-area: trhs;
    padding-left: 50%;
  }
</style>

<script>
  // Types for better type
  // This can me moved to an external .ts file.
  interface LightboxElements {
    thumbnailButtons: NodeListOf<HTMLButtonElement>;
    lightboxDialog: HTMLDialogElement | null;
    prevButton: HTMLButtonElement | null;
    nextButton: HTMLButtonElement | null;
    closeButton: HTMLButtonElement | null;
  }

  interface LightboxState {
    currentIndex: number;
    resizeTimeout?: number;
    closeDuration: number;
    debug: boolean;
  }

  document.addEventListener("astro:page-load", () => {
    // Select grid items instead of thumbnail buttons
    const portfolioItems = document.querySelectorAll<HTMLElement>(
      "[data-portfolio-item]",
    );
    const lightboxDialog =
      document.querySelector<HTMLDialogElement>(".lightbox-dialog");
    const prevButton =
      document.querySelector<HTMLButtonElement>(".prev-button");
    const nextButton =
      document.querySelector<HTMLButtonElement>(".next-button");
    const closeButton =
      document.querySelector<HTMLButtonElement>(".close-button");

    const debug = false; // Enable debug logging

    // Early exit if lightbox dialog doesn't exist on this page
    if (!lightboxDialog) {
      return;
    }

    // Create an AbortController to clean up event listeners when navigating away
    const abortController = new AbortController();
    const signal = abortController.signal;

    // Set closeDuration from CSS custom property
    const closeDuration =
      parseFloat(
        getComputedStyle(lightboxDialog).getPropertyValue(
          "--duration-close-transition",
        ),
      ) * 1000; // Convert seconds to milliseconds

    let currentIndex = 0;
    let resizeTimeout: number | undefined;

    function logDebugInfo(
      action: string,
      rect?: DOMRect,
      image?: HTMLImageElement,
    ): void {
      if (!debug) return;

      console.log(`Transition: ${lightboxDialog?.getAttribute("data-option")}`);
      console.log(`Debug Info (${action}):`);
      if (rect) {
        console.log(
          `Thumbnail Position: X=${rect.left}, Y=${rect.top}, Width=${rect.width}, Height=${rect.height}`,
        );
      }
      if (image) {
        const imgRect = image.getBoundingClientRect();
        console.log(
          `Target Image Position: X=${imgRect.left}, Y=${imgRect.top}, Width=${imgRect.width}, Height=${imgRect.height}`,
        );
      }
    }

    function calculateCentering(image: HTMLImageElement): void {
      const wrapper = image.closest(".lightbox-image-wrapper") as HTMLElement;

      if (!wrapper) {
        console.error("Image wrapper not found.");
        return;
      }

      const wrapperRect = wrapper.getBoundingClientRect();
      const wrapperWidth = wrapperRect.width;
      const wrapperHeight = wrapperRect.height;

      if (!wrapperWidth || !wrapperHeight) return;

      const imageWidth = Number.parseFloat(image.getAttribute("width") || "0");
      const imageHeight = Number.parseFloat(
        image.getAttribute("height") || "0",
      );

      if (!imageWidth || !imageHeight) {
        console.error("Image dimensions are invalid.");
        return;
      }

      const imageAspectRatio = imageWidth / imageHeight;
      const wrapperAspectRatio = wrapperWidth / wrapperHeight;

      let finalX = 0;
      let finalY = 0;

      if (wrapperAspectRatio > imageAspectRatio) {
        const targetHeight = wrapperHeight;
        const targetWidth = targetHeight * imageAspectRatio;
        finalX = (wrapperWidth - targetWidth) / 2; // Center horizontally
      } else {
        const targetWidth = wrapperWidth;
        const targetHeight = targetWidth / imageAspectRatio;
        finalY = (wrapperHeight - targetHeight) / 2; // Center vertically
      }

      finalX = Math.max(0, finalX);
      finalY = Math.max(0, finalY);

      image.style.setProperty("--final-x", `${finalX}px`);
      image.style.setProperty("--final-y", `${finalY}px`);
      image.style.setProperty("--final-scale", `1`);
    }

    function showImageAtIndex(index: number): void {
      const lightboxImageContainers = document.querySelectorAll<HTMLElement>(
        ".lightbox-image-container",
      );

      if (index < 0 || index >= lightboxImageContainers.length) return;

      for (const container of lightboxImageContainers) {
        container.classList.remove("active", "previous", "next");
      }

      const newActiveImage = document.getElementById(`image-${index}`);
      if (newActiveImage) {
        newActiveImage.classList.add("active");
        currentIndex = index;

        const image =
          newActiveImage.querySelector<HTMLImageElement>(".lightbox-image");
        if (image) {
          logDebugInfo("Image Loaded", undefined, image);
          calculateCentering(image);
        }

        const prevIndex =
          (currentIndex - 1 + lightboxImageContainers.length) %
          lightboxImageContainers.length;
        const nextIndex = (currentIndex + 1) % lightboxImageContainers.length;

        const prevImage = document.getElementById(`image-${prevIndex}`);
        const nextImage = document.getElementById(`image-${nextIndex}`);

        prevImage?.classList.add("previous");
        nextImage?.classList.add("next");
      } else {
        console.error(`Image container with id image-${index} not found.`);
      }
    }

    function openLightbox(item: HTMLElement): void {
      if (!lightboxDialog) return;

      const rect = item.getBoundingClientRect();
      const index = Number.parseInt(item.dataset.index || "0", 10);

      const activeImage = document.getElementById(`image-${index}`);
      if (activeImage) {
        activeImage.classList.add("active");
        lightboxDialog.showModal();
        currentIndex = index;

        requestAnimationFrame(() => {
          const lightboxWrapper = activeImage.querySelector<HTMLDivElement>(
            ".lightbox-image-wrapper",
          );

          if (!lightboxWrapper) {
            console.error("Lightbox wrapper not found.");
            return;
          }

          const wrapperRect = lightboxWrapper.getBoundingClientRect();
          if (wrapperRect.width === 0 || wrapperRect.height === 0) {
            console.error("Lightbox image wrapper has zero dimensions.");
            return;
          }

          const lightboxImage =
            activeImage.querySelector<HTMLImageElement>(".lightbox-image");
          if (lightboxImage) {
            const buttonAspectRatio = rect.width / rect.height;
            const wrapperAspectRatio = wrapperRect.width / wrapperRect.height;

            const initialScale =
              buttonAspectRatio > wrapperAspectRatio
                ? rect.width / wrapperRect.width
                : rect.height / wrapperRect.height;

            lightboxImage.style.setProperty("--initial-x", `${rect.left}px`);
            lightboxImage.style.setProperty("--initial-y", `${rect.top}px`);
            lightboxImage.style.setProperty(
              "--initial-scale",
              `${initialScale}`,
            );

            logDebugInfo("Thumbnail Clicked", rect);

            if (lightboxDialog.getAttribute("data-option") !== "slide") {
              calculateCentering(lightboxImage);
            }

            showImageAtIndex(currentIndex);
          }
        });
      }
    }

    function showPreviousImage(): void {
      const prevIndex =
        (currentIndex - 1 + portfolioItems.length) % portfolioItems.length;
      showImageAtIndex(prevIndex);
    }

    function showNextImage(): void {
      const nextIndex = (currentIndex + 1) % portfolioItems.length;
      showImageAtIndex(nextIndex);
    }

    function handleKeydown(event: KeyboardEvent): void {
      if (!lightboxDialog || !lightboxDialog.open) return;

      if (event.key === "ArrowLeft") {
        showPreviousImage();
      } else if (event.key === "ArrowRight") {
        showNextImage();
      } else if (event.key === "Escape") {
        event.preventDefault(); // Prevent the default action (closing the dialog)
        closeDialog(); // Call custom close function
      }
    }

    function applyCenteringToAllImages(): void {
      const lightboxImages =
        document.querySelectorAll<HTMLImageElement>(".lightbox-image");
      lightboxImages.forEach(calculateCentering);
    }

    function handleSwipe(event: TouchEvent): void {
      const touchStartX = event.touches[0].clientX;

      function handleTouchEnd(touchEndEvent: TouchEvent): void {
        const touchEndX = touchEndEvent.changedTouches[0].clientX;
        const deltaX = touchEndX - touchStartX;

        if (deltaX > 50) {
          showPreviousImage();
        } else if (deltaX < -50) {
          showNextImage();
        }
        document.removeEventListener("touchend", handleTouchEnd);
      }
      document.addEventListener("touchend", handleTouchEnd);
    }
    // Function to close the dialog
    // Do not execute .close() until after transitions have completed
    function closeDialog() {
      if (lightboxDialog) {
        lightboxDialog.classList.add("closing"); // Add class for transition
        // Get the current timestamp when closing starts
        const startTime = Date.now();

        // Delay the actual closing of the dialog
        setTimeout(() => {
          lightboxDialog.close(); // Close the dialog after transition
          lightboxDialog.classList.remove("closing"); // Clean up class

          // Calculate and log the duration
          const endTime = Date.now();
          const duration = endTime - startTime;
          console.log(`Dialog closing transition duration: ${duration} ms`);
        }, closeDuration);
      }
    }

    // Attach event listeners with abort signal for cleanup
    // Listen to clicks on portfolio grid items
    for (const item of portfolioItems) {
      item.addEventListener("click", () => openLightbox(item), { signal });
      // Add cursor pointer style
      item.style.cursor = "pointer";
    }
    prevButton?.addEventListener("click", showPreviousImage, { signal });
    nextButton?.addEventListener("click", showNextImage, { signal });
    closeButton?.addEventListener("click", closeDialog, { signal });
    document.addEventListener("keydown", handleKeydown, { signal });
    document.addEventListener("touchstart", handleSwipe, { signal });

    // Handle centering on resize with debouncing
    window.addEventListener(
      "resize",
      () => {
        clearTimeout(resizeTimeout);
        resizeTimeout = window.setTimeout(applyCenteringToAllImages, 300);
      },
      { signal },
    );

    // Clean up classes on dialog close event
    lightboxDialog?.addEventListener(
      "close",
      () => {
        const lightboxImageContainers = document.querySelectorAll<HTMLElement>(
          ".lightbox-image-container",
        );

        // Clean up active classes
        for (const container of lightboxImageContainers) {
          container.classList.remove("active", "previous", "next");
        }
      },
      { signal },
    );

    // Clean up event listeners when navigating away
    document.addEventListener(
      "astro:before-preparation",
      () => {
        abortController.abort();
      },
      { once: true },
    );
  });
</script>
