---
import BaseLayout from '../layouts/BaseLayout.astro'
import { getCollection } from 'astro:content'
import Portfoliobox from '../components/Portfoliobox.astro'

import { portfolioCategories } from "../utils/resourceColors";

import SocialIcons from '../components/blocks/SocialIcons.astro'
import SocialIconsFooter from '../components/blocks/SocialIconsFooter.astro'

const pageTitle = "Portfolio"

// Get portfolio collection and sort by order
const allPortfolio = await getCollection('portfolio');
const sortedPortfolio = allPortfolio
  .filter(item => item.data.order !== undefined)
  .sort((a, b) => a.data.order - b.data.order);
---

<style>

.lightbox-dialog {
  /* Adjust these custom properties if you like */
  --duration-zoom-in: 1.2s; /* Duration of the zoom effect */
  --duration-background-transition: 0.5s; /* Duration of lightbox background transition*/
  --duration-slide-transition: 0.5s; /* Duration of slide transition*/
  --duration-close-transition: 0.75s; /* close*/
  --caption-height: 5lh; /* use line height units for size of caption area */
  --ease-zoom: cubic-bezier(0.5, -0.5, 0.1, 1.5);
  --ease-slide-transition: cubic-bezier(0.9, 0, 0.1, 1);
}

</style>

<BaseLayout pageTitle={`${pageTitle} blog`}>

  <!-- Portfolio Lightbox (using markdown data) -->
  <Portfoliobox portfolioItems={sortedPortfolio} transitionType="fade" />

  <div class="px-2 pt-4 md:pt-6 md:px-0">
      <h2 class="pt-4 text-4xl font-extrabold text-center text-white uppercase md:pt-16 md:text-7xl drop-shadow-lg">
          Portfolio
      </h2>
      <div class="mt-6 font-extrabold text-center text-white uppercase md:mt-14 drop-shadow-lg">
          <form class="relative max-w-2xl p-0 mx-auto transition-all duration-300 ease-in-out rounded-lg bg-black/40 hover:bg-black/80">
              <input
                  id="search-input"
                  class="w-full px-5 py-3 pr-12 mt-0 text-2xl text-white bg-transparent border-none rounded-lg hover:ring-1"
                  type="text" placeholder="Search..." />
              <button
                  id="clear-search"
                  type="button"
                  class="absolute hidden transition-all duration-200 transform -translate-y-1/2 right-4 top-1/2 hover:scale-110"
                  aria-label="Clear search">
                  <svg class="w-6 h-6 text-white opacity-60 hover:opacity-100" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                      <circle cx="12" cy="12" r="10" stroke-width="2"/>
                      <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 9l-6 6m0-6l6 6"/>
                  </svg>
              </button>
          </form>
      </div>
      <ul
          class="flex items-center w-full pb-6 mx-auto mt-4 overflow-x-auto font-bold tracking-wider text-center text-yellow-400 uppercase divide-x-2 cursor-pointer divide-yellow-600/20 border-opacity-20 text-md drop-shadow-md md:justify-center md:overflow-x-visible scrollbar-hide snap-x snap-mandatory">
          {portfolioCategories.map((category) => (
            <li
              class="flex-shrink-0 px-3 transition-all duration-500 opacity-40 hover:opacity-100 snap-center"
              data-category-filter={category.name}
              data-category-tags={category.tags.join(',')}
            >
              {category.name}
            </li>
          ))}
      </ul>
  </div>

  <!-- consider: adding a wrapper container for the 16px extra padding that isn't respected by grid. can't use margin because mx-auto is already in use-->
  <div class="container grid grid-cols-2 gap-2 p-2 mx-auto mt-12 text-white max-w-7xl sm:p-4 sm:gap-4 sm:grid-cols-3 lg:grid-cols-4 portfolio-grid" data-mode="curated">

    <!-- Title Card -->
    <div class="flex items-center justify-center col-span-2 border rounded-lg shadow-inner bg-gray-950 border-white/10 bg-opacity-40 sm:col-span-3 md:col-span-2">
      <h1 class="p-1 m-0 text-6xl font-extrabold tracking-wide text-transparent uppercase bg-clip-text bg-gradient-to-r from-yellow-400 to-pink-500">
        Portfolio
      </h1>
    </div>

    <!-- Dynamic Portfolio Items -->
    {sortedPortfolio.map((item, index) => {
      // Build grid classes based on frontmatter
      const gridClasses = [
        'card-zoom',
        'portfolio-item',
        item.data.gridSpan !== 'default' ? item.data.gridSpan : '',
        item.data.aspectRatio === 'golden' ? 'aspect-golden' : '',
        item.data.gridPosition || ''
      ].filter(Boolean).join(' ');

      return (
        <div
          class={gridClasses}
          data-portfolio-item
          data-index={index}
          data-title={item.data.title}
          data-categories={item.data.category.join(',')}
        >
          <div class="card-zoom-image" style={`background-image: url('${item.data.image}')`}></div>
          {item.data.showOverlay && (
            <h3 class="hidden text-center uppercase text-md md:block md:text-2xl lg:text-3xl card-zoom-text xl:text-4xl">
              {item.data.title}
            </h3>
          )}
        </div>
      );
    })}

  </div>

  <script>
    // Portfolio filtering and dual-mode layout (Enhanced with URL hash support)
    document.addEventListener('astro:page-load', () => {
      const portfolioGrid = document.querySelector('.portfolio-grid');
      const portfolioItems = document.querySelectorAll('[data-portfolio-item]');
      const searchInput = document.getElementById('search-input') as HTMLInputElement | null;
      const clearButton = document.getElementById('clear-search');
      const categoryButtons = document.querySelectorAll('[data-category-filter]');

      let activeFilter = 'all';

      // Create AbortController for cleanup
      const abortController = new AbortController();
      const signal = abortController.signal;

      // Update URL hash with current search/filter state
      function updateHash(value: string) {
        if (value) {
          window.location.hash = encodeURIComponent(value);
        } else {
          // Clear hash without adding to history
          history.replaceState(null, '', window.location.pathname);
        }
      }

      // Show/hide clear button based on input value
      function toggleClearButton() {
        if (!searchInput || !clearButton) return;
        if (searchInput.value.length > 0) {
          clearButton.classList.remove('hidden');
        } else {
          clearButton.classList.add('hidden');
        }
      }

      // Update grid mode based on filter state
      function updateGridMode() {
        if (activeFilter === 'all') {
          portfolioGrid?.setAttribute('data-mode', 'curated');
        } else {
          portfolioGrid?.setAttribute('data-mode', 'filtered');
        }
      }

      // Filter items by category
      function filterByCategory(categoryTags: string) {
        const tags = categoryTags.split(',').map(t => t.trim().toLowerCase());

        portfolioItems.forEach(item => {
          const itemElement = item as HTMLElement;
          const itemCategories = itemElement.dataset.categories?.toLowerCase() || '';
          const matches = tags.some(tag => itemCategories.includes(tag));

          if (matches || categoryTags === 'all') {
            itemElement.removeAttribute('data-hidden');
          } else {
            itemElement.setAttribute('data-hidden', 'true');
          }
        });
      }

      // Filter items by search query
      function filterBySearch(query: string) {
        const lowerQuery = query.toLowerCase();

        portfolioItems.forEach(item => {
          const itemElement = item as HTMLElement;
          const title = itemElement.dataset.title?.toLowerCase() || '';
          const categories = itemElement.dataset.categories?.toLowerCase() || '';
          const matches = title.includes(lowerQuery) || categories.includes(lowerQuery);

          if (matches || query === '') {
            itemElement.removeAttribute('data-hidden');
          } else {
            itemElement.setAttribute('data-hidden', 'true');
          }
        });
      }

      // Category filter buttons
      categoryButtons.forEach(button => {
        button.addEventListener('click', (e) => {
          e.preventDefault();
          const buttonElement = button as HTMLElement;
          const categoryName = buttonElement.dataset.categoryFilter || 'All';
          const categoryTags = buttonElement.dataset.categoryTags || '';

          // If "All" category, clear search and show all
          if (categoryName === 'All' || categoryTags === '') {
            if (searchInput) {
              searchInput.value = '';
              searchInput.dispatchEvent(new Event('input'));
            }
            updateHash('');
            return;
          }

          // Populate search box with lowercase category name
          const lowerCategoryName = categoryName.toLowerCase();
          if (searchInput) {
            searchInput.value = lowerCategoryName;
            toggleClearButton(); // Show clear button
          }

          // Filter by category tags
          const tagsArray = categoryTags.split(',');
          portfolioItems.forEach(item => {
            const itemElement = item as HTMLElement;
            const itemCategories = itemElement.dataset.categories?.toLowerCase() || '';

            // Check if any of the category tags match
            const matches = tagsArray.some(tag => itemCategories.includes(tag.toLowerCase()));

            if (matches) {
              itemElement.removeAttribute('data-hidden');
            } else {
              itemElement.setAttribute('data-hidden', 'true');
            }
          });

          // Update active state
          categoryButtons.forEach(btn => btn.classList.remove('opacity-100'));
          categoryButtons.forEach(btn => btn.classList.add('opacity-40'));
          button.classList.remove('opacity-40');
          button.classList.add('opacity-100');

          // Update grid mode
          activeFilter = lowerCategoryName;
          updateGridMode();

          // Update URL hash
          updateHash(lowerCategoryName);
        }, { signal });
      });

      // Search input with debounce
      let searchTimeout: number;
      searchInput?.addEventListener('input', (e) => {
        const query = (e.target as HTMLInputElement).value;

        // Toggle clear button visibility
        toggleClearButton();

        // Clear category selection
        categoryButtons.forEach(btn => {
          btn.classList.remove('opacity-100');
          btn.classList.add('opacity-40');
        });

        // Apply filter
        if (query === '') {
          activeFilter = 'all';
          portfolioItems.forEach(item => (item as HTMLElement).removeAttribute('data-hidden'));
        } else {
          activeFilter = 'search';
          filterBySearch(query);
        }

        updateGridMode();

        // Update URL hash with debounce (500ms)
        clearTimeout(searchTimeout);
        searchTimeout = setTimeout(() => {
          updateHash(query.toLowerCase());
        }, 500);
      }, { signal });

      // Clear search button
      clearButton?.addEventListener('click', () => {
        if (searchInput) {
          searchInput.value = '';
          searchInput.dispatchEvent(new Event('input'));
          searchInput.focus();
        }
      }, { signal });

      // Read hash on page load and restore filter state
      const hash = window.location.hash.slice(1); // Remove #
      if (hash) {
        const decodedHash = decodeURIComponent(hash).toLowerCase();

        // Check if it's a category name (case-insensitive)
        const categoryButton = Array.from(categoryButtons).find(
          btn => (btn as HTMLElement).dataset.categoryFilter?.toLowerCase() === decodedHash
        );

        if (categoryButton) {
          // It's a category - click it
          (categoryButton as HTMLElement).click();
        } else if (searchInput) {
          // It's a search term - populate search
          searchInput.value = decodedHash;
          searchInput.dispatchEvent(new Event('input'));
        }
      }

      // Clean up event listeners when navigating away
      document.addEventListener('astro:before-preparation', () => {
        abortController.abort();
      }, { once: true });
    });
  </script>

</BaseLayout>
